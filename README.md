Реалізовано 2 версії програми першу через підхід Work stealing, другу – Work dealing. Work stealing швидше справляється зі своєю задачею, оскільки при використанні підходу Work dealing витрачається час на перевірку,
чи потік є перенавантаженим, потім на "клик про допомогу" і пошук потоку, який може "допомогти". В той час як при використанні підходу Work stealing коли якийсь потік закінчив виконання завдань зі своєї черги то він 
просто "краде" завдання з найбільш завантаженого потоку, таким чином потоки не стоять без діла. Якщо спрощувати, то ніхто не стане заперечувати, що підійти і вкрасти щось набагато простіше і швидше ніж зрозуміти, що 
у тебе велике навантаження, потім попросити про допомогу і знайти того, хто допоможе.


Work stealing

ForkJoinPool pool = new ForkJoinPool(Runtime.getRuntime().availableProcessors());
Створюється пул потоків ForkJoinPool, який використовує кількість доступних процесорів у системі для паралельного виконання завдань.

Створюється та викликається задача SumTask, яка обчислює суму елементів масиву array від індексу 0 до n - 1 з використанням заданого порогу threshold.

Клас SumTask успадковується від RecursiveTask<Integer>, що дозволяє використовувати його в ForkJoinPool для паралельного обчислення. Задача зберігає масив, діапазон індексів для обробки, та поріг threshold.

Метод compute містить логіку для обчислення суми елементів масиву.Якщо кількість елементів між індексами start і end менша або рівна порогу threshold, виконується безпосереднє обчислення суми.
Якщо кількість елементів більша за поріг, завдання розподіляється на дві підзадачі. Ліва підзадача (leftTask) запускається паралельно, а права частина (rightTask) обробляється поточним потоком

Після обробки правої частини (викликається безпосередньо методом compute), очікується результат лівої частини через метод join.

Work dealing

ExecutorService створює пул потоків з кількістю потоків, яка дорівнює кількості доступних процесорів.
BlockingQueue<SumTask> використовується для зберігання та обробки завдань (SumTask). Черга дозволяє потокам отримувати нові завдання для обробки.

List<Future<Integer>> futures = new ArrayList<>();
for (int i = 0; i < Runtime.getRuntime().availableProcessors(); i++) {
    futures.add(executor.submit(() -> {
        while (true) {
            SumTask task = taskQueue.poll();
            if (task == null) {
                break; // Вихід, якщо немає завдань
            }
            try {
                task.call();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return null;
    }));
}
Створюється кілька потоків, кожен з яких отримує завдання з черги і виконує метод call() для обробки цього завдання. Якщо завдань більше немає (черга порожня), потік припиняє виконання.
Результати виконання задач зберігаються в futures для подальшого очікування їх завершення.

for (Future<Integer> future : futures) {
    future.get();
}
Очікуємо завершення виконання всіх потоків, викликаючи get() для кожного елементу в списку futures.

Опис класу SumTask
taskQueue: черга для зберігання підзадач.
executor: пул потоків, для виконання завдань.

Метод call() виконує:
Якщо діапазон елементів малий (менше або рівно порогу), обчислюється сума для цього діапазону.
Якщо завдання займає більше ніж 1 мілісекунду, воно розбивається на дві підзадачі і додається в чергу для обробки іншими потоками. Це здійснюється для ефективного використання ресурсів і уникнення перевантаження окремих потоків.
